using System;
using System.IO;
using Mono.Options;

namespace BehaveN.Tool
{
    [Summary("Generates test fixtures for the scenarios contained in text files")]
    public class GenerateCommand : ICommand
    {
        public static void WriteHelp()
        {
            Console.WriteLine("usage: BehaveN.Tool Generate [OPTION]... <filepattern>...");
            Console.WriteLine();
            Console.WriteLine("<filepattern> can be the path to any file. Wildcards don't work yet.");
            Console.WriteLine("All files are considered to be text files containing scenarios. A .g.cs");
            Console.WriteLine("file will be generated next to each text file containing the test");
            Console.WriteLine("fixtures.");
            Console.WriteLine();
            Console.WriteLine("NOTE: You need to specify at least one text file!");
            Console.WriteLine();
            Console.WriteLine("options:");
            Console.WriteLine();
            GetOptions().WriteOptionDescriptions(Console.Out);
        }

        static string ns = "MyNamespace";
        static string baseClass = null;
        static bool noSetUp = false;
        static bool noTearDown = false;
        static string assemblyName = null;

        public int Run(string[] args)
        {
            OptionSet options = GetOptions();

            var files = options.Parse(args);

            if (files.Count < 1)
                return -1;

            foreach (var file in files)
            {
                var specs = new SpecificationsFile();
                specs.LoadFile(file);

                string className = Path.GetFileNameWithoutExtension(file);
                string csFile = Path.ChangeExtension(file, ".g.cs");

                Console.WriteLine("Writing to " + csFile);

                StringWriter sw = new StringWriter();

                sw.WriteLine("// This code was generated by the BehaveN tool.");
                sw.WriteLine();

                sw.WriteLine("using BehaveN;");
                sw.WriteLine("using NUnit.Framework;");
                sw.WriteLine("using System.Reflection;");
                sw.WriteLine();
                sw.WriteLine("namespace {0}", ns);
                sw.WriteLine("{");

                sw.WriteLine("    [TestFixture]");
                sw.WriteLine("    public partial class {0}{1}", className, (baseClass != null) ? " : " + baseClass : "");
                sw.WriteLine("    {");

                sw.WriteLine(@"        private SpecificationsFile _specs = new SpecificationsFile();");

                if (!noSetUp)
                {
                    sw.WriteLine(@"
        [TestFixtureSetUp]
        public void LoadScenarios()
        {{
            _specs.StepDefinitions.UseStepDefinitionsFromAssembly({1});
            _specs.LoadEmbeddedResource(GetType().Assembly, ""{0}"");
        }}", Path.GetFileName(file), (assemblyName == null) ? "GetType().Assembly" : @"Assembly.Load(""" + assemblyName + @""")");
                }

                if (!noTearDown)
                {
                    sw.WriteLine(@"
        [TestFixtureTearDown]
        public void ReportUndefinedSteps()
        {
            _specs.ReportUndefinedSteps();
        }");
                }

                foreach (var scenario in specs.Scenarios)
                {
                    sw.WriteLine();

                    sw.WriteLine("        [Test]");
                    sw.WriteLine("        public void {0}()", scenario.Name.Replace(" ", "_"));
                    sw.WriteLine("        {");
                    sw.WriteLine("            _specs.Scenarios[\"{0}\"].Verify();", scenario.Name);
                    sw.WriteLine("        }");
                }

                sw.WriteLine("    }");

                sw.WriteLine("}");

                string oldText = "";

                if (File.Exists(csFile))
                {
                    oldText = File.ReadAllText(csFile);
                }

                string newText = sw.GetStringBuilder().ToString();

                if (oldText != newText)
                {
                    File.WriteAllText(csFile, newText);
                }
            }

            return 0;
        }

        private static OptionSet GetOptions()
        {
            var options = new OptionSet();
            options.Add("namespace=", "the namespace for the generated classes", s => ns = s);
            options.Add("base-class=", "the base class for the generated classes", s => baseClass = s);
            options.Add("no-setup", "do not generate a test fixture set up method", s => noSetUp = true);
            options.Add("no-teardown", "do not generate a test fixture tear down method", s => noTearDown = true);
            options.Add("assembly=", "the assembly that contains the step definitions", s => assemblyName = s);
            return options;
        }
    }
}
